---
title: "<strong>R6</strong>"
author: "andrés castro araújo"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output: 
  html_document: 
    theme: paper
    toc: yes
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", fig.align = "center")

`%>%` <- magrittr::`%>%`
```

```{css, echo=FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    color: #828282;
    border-left: 10px solid #EEE;
}

body {
    font-size: 14px;
}
```

## Introduction

The R6 system has two special properties:

1. It uses the encapsulated OOP paradigm. This means that methods belong to objects (instead of generic functions), and you call them like `object$method()`.

2. R6 objects are _mutable_, they are modified-in-place (i.e. they have "reference semantics"). This means that using methods can modify objects directly.

    For example:

    ```{r, eval=FALSE}
    object             ## obj has a value
    object$modify()    ## method modifies value
    object             ## obj has a different value
    ```

    More importantly, it means that objects are not copied when modified, this is why we need to `$clone()` R6 objects instead. More on that later.

These properties make it resemble OOP in Python, JavaScript, or basically any other popular programming language (except for Julia).

## Classes and methods

>[__R6__](https://r6.r-lib.org/index.html) only needs a single function call to create both the class and its methods: `R6::R6Class()`. This is the only function from the package that you’ll ever use!

The following example uses the two most important arguments in `R6Class()`:

1. `classname`: By convention, R6 classes have UpperCamelCase names. This also makes it possible to use R6 objects and S3 generics.

2. `public`: Supplies a list of __methods__ (i.e. functions) and __fields__ (i.e. anything else) that make up the public interface of the object. By convention, methods and fields use snake_case. Methods can access the methods and fields of the current object via `self$...`

```{r}
library(R6)

Accumulator <- R6Class("Accumulator", list(
  sum = 0,
  add = function(x = 1) {
    self$sum <- self$sum + x 
    invisible(self)
  })
)
```

>You should always assign the result of `R6Class()` into a variable with the same name as the class, because `R6Class()` returns an R6 object that defines the class:

```{r}
Accumulator
```

>You construct a new object from the class by calling the `new()` method. In R6, methods belong to objects, so you use `$` to access `new()`:

```{r}
x <- Accumulator$new()
```

Finally, you can call the methods and access the fields in `public` with the `$` operator.

```{r}
x$sum
x$add(25)
x$sum
x$add(1)$add(2)$add(3) ## method chaining
x$sum
```

When thinking about the translation between S3 and R6, recall that we talk about __fields__ and __methods__ as opposed to __variables__ and __functions__.

## Important methods

Two important methods _should_ be defined for most classes: 

1. `$initialize()` overrides the default behaviour of `$new()`.

2. `$print()` allows you to override the default printing behaviour. As with any R6 method called for its side effects, `$print()` should return `invisible(self)`.

```{r, error=TRUE}
Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)
    
    self$name <- name
    self$age <- age
  }, 
  
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age:  ", self$age, "\n", sep = "")
    invisible(self)
  }
))

andres <- Person$new(name = "Andrés", age = "thirty")
andres <- Person$new("Andrés", NA_integer_)
andres
```

You can also add new elements to an existing class with `$set()`. You just have to supply the _visibility_, the _name_, and the _component_.

```{r}
Accumulator <- R6Class("Accumulator")
Accumulator$set(which = "public", name = "sum", value = 0)
Accumulator$set("public", "add", function(x = 1) {
  self$sum <- self$sum + x 
  invisible(self)
})
```

___Inheritance___

>To inherit behaviour from an existing class, provide the class object to the `inherit` argument:

```{r}
AccumulatorChatty <- R6Class("AccumulatorChatty", 
  inherit = Accumulator,
  public = list(
    add = function(x = 1) {
      cat("Adding ", x, "\n", sep = "")
      super$add(x = x)
    }
  )
)

x2 <- AccumulatorChatty$new()
x2$add(10)$add(1)$sum
```

>`$add()` overrides the superclass implementation, but we can still delegate to the superclass implementation by using `super$`. (This is analogous to `NextMethod()`). Any methods which are not overridden will use the implementation in the parent class.

___Exercises___

>Create a bank account R6 class that stores a balance and allows you to deposit and withdraw money.

```{r}
BankAccount <- R6Class(classname = "BankAccount", public = list(
  balance = NULL,
  initialize = function(original_deposit) {
    stopifnot(is.numeric(original_deposit))
    self$balance <- original_deposit
  },
  
  withdraw = function(x) {
    self$balance <- self$balance - x
    cat("-", x, "\n", sep = "")
    invisible(self)
  },
  deposit = function(x) {
    self$balance <- self$balance + x
    cat("+", x, "\n", sep = "")
    invisible(self)
  },
  
  print = function(...) {
    cat("Your balance is", self$balance, "dollars.")
  }
))
```

>Create a subclass that throws an error if you attempt to go into overdraft. 

```{r, error=TRUE}
BankAccountError <- R6Class("BankAccountError",
  inherit = BankAccount,
  public = list(
    withdraw = function(x) {
      if (self$balance - x < 0) {
        stop("Your `withdraw` must be smaller ", "than your `balance`.")
      }
      super$withdraw(x)
    }
))

account <- BankAccountError$new(10)

account$
  deposit(20)$
  withdraw(50)
```

>Create another subclass that allows you to go into overdraft, but charges you a fee.

```{r}
BankAccountOverCharge <- R6Class("BankAccountOverCharge",
  inherit = BankAccount,
  public = list(
    withdraw = function(x) {
      fee <- 5
      if (self$balance - x < 0) {
          cat(fee, " dollars extra fee!\n", sep = "")
          super$withdraw(x + fee)
          invisible(self)
      } else {
        super$withdraw(x)
      }
    }
))

account <- BankAccountOverCharge$new(10)

account$withdraw(20)
account
```

>Create an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with `$draw(n)`, and return all cards to the deck and reshuffle with `$reshuffle()`.

```{r}
Deck <- R6Class("Deck", list(
  deck = NULL,
  out_of_deck = NULL,
  
  initialize = function() {
    suit <- c("♠", "♥", "♦", "♣")
    value <- c("A", 2:10, "J", "Q", "K")
    self$deck <- sample(paste0(rep(value, 4), suit))
  },
  
  draw = function(n) {
    x <- sample(self$deck, size = n)
    cat(x, "\n")
    self$out_of_deck <- append(x, self$out_of_deck)
    self$deck <- setdiff(self$deck, self$out_of_deck)
    invisible(self)
  },
  
  reshuffle = function() {
    self$deck <- sample(c(self$deck, self$out_of_deck))
    self$out_of_deck <- NULL
    invisible(self)
  },
  
  print = function(...) {
    cat("Number of cards in deck:", length(self$deck), "\n")
    cat("Number of cards outside deck:", length(self$out_of_deck), "\n")
  }
))

deck <- Deck$new()

deck$draw(5)$draw(5)$draw(5)
deck

deck$reshuffle()
deck
```

>Why can’t you model a bank account or a deck of cards with an S3 class?

S3 follows R's standard _copy-on-modify_ semantics. If we were to model a bank account using S3, we would have to create multiple modified bank accounts and keep track of the one we're ultimately interested in. This sort of problem seems more natural to approach via object oriented 

>Create an R6 class that allows you to get and set the current timezone. You can access the current timezone with Sys.timezone() and set it with Sys.setenv(TZ = "newtimezone"). When setting the time zone, make sure the new time zone is in the list provided by OlsonNames().


```{r}
## MAYBE THIS DOESN'T WORK WITHOUT ADMINISTRATOR PRIVILEDGES
TimeManager <- R6Class("TimeManager", list(
  get = function() Sys.timezone(),
  set = function(tz = OlsonNames()) {
    x <- match.arg(tz)
    Sys.setenv(TZ = x)
  }
))

tz <- TimeManager$new()

tz$set("America/Bogota")

x <- "America/Bogota"

Sys.setenv(TZ = x)
Sys.timezone()
```

>Create an R6 class that manages the current working directory. It should have `$get()` and `$set()` methods.

```{r}
WorkingDirectory <- R6Class("WorkingDirectory", list(
  get = function() {
    getwd()
  },
  set = function(value) {
    setwd(value)
  }
))
```



## Controlling access

The `R6Class()` function has two other arguments that work similarly to `public`:

- `private` allows you to create fields and methods that are only available from within the class, not outside of it.

    It works just like the `public` argument. You give it a list of methods (functions) and fiels (everything else). These are available within methods using `private$` (instead of `$self`). You cannot access private fields or methods outside of the class.
    
    >The distinction between public and private fields is important when you create complex networks of classes, and you want to make it as clear as possible what it's ok for others to access. Anything that's private can be more easily refactored because you know others aren't relying on it. Private methods tend to be less important in R compared to other programming languages because the object hierarchies in R tend to be simpler.

- `active` allows you to define _dynamic_ (or _active_) fields. Active fields are implemented using __active bindings__. Each of these active bindings looks like a field from the outside, but is defined with functions (like methods).

    >Each active binding is a function that takes a single argument: `value`. If the argument is `missing()`, the value is being retrieved; otherwise it's being modified.
    
    For example:
    
    ```{r}
    Rando <- R6::R6Class("Rando", active = list(
      random = function(value) {
        if (missing(value)) {
          runif(1)  
        } else {
          stop("Can't set `$random`", call. = FALSE)
        }
      }
    ))
    
    y <- Rando$new()
    y$random
    y$random
    ```
    
## Cloning

>The primary consequence of reference semantics is that objects are not copied when modified.

```{r}
x <- Accumulator$new() 
y <- x

## They have the same memory address:
c(lobstr::obj_addr(y), lobstr::obj_addr(x))

y$add(10)
c(y = y$sum, x = x$sum)
```

Instead, we need to `$clone()` the object.

```{r}
x <- Accumulator$new() 
y <- x$clone()

## They have a different memory address:
c(lobstr::obj_addr(y), lobstr::obj_addr(x))

y$add(10)
c(y = y$sum, x = x$sum)
```

****

Read more about R6 [__here__](https://r6.r-lib.org/).

****

To do:

update with slides from https://blog.revolutionanalytics.com/2017/07/the-r6-class-system.html

functional vs encapsulated

