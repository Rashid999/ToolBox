---
title: "<strong>R6</strong>"
author: "andrés castro araújo"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output: 
  html_document: 
    theme: paper
    toc: yes
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", fig.align = "center")

`%>%` <- magrittr::`%>%`
```

```{css, echo=FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    color: #828282;
    border-left: 10px solid #EEE;
}

body {
    font-size: 14px;
}
```

## Introduction

The R6 system has two special properties:

1. It uses the encapsulated OOP paradigm. This means that methods belong to objects (instead of generic functions), and you call them like `object$method()`.

2. R6 objects are _mutable_, they are modified-in-place (i.e. they have "reference semantics"). This means that using methods can modify objects directly.

    For example:

    ```{r, eval=FALSE}
    object             ## obj has a value
    object$modify()    ## method modifies value
    object             ## obj has a different value
    ```

These properties make it resemble OOP in Python, JavaScript, or basically any other popular programming language (except for Julia).

## Classes and methods

>[__R6__](https://r6.r-lib.org/index.html) only needs a single function call to create both the class and its methods: `R6::R6Class()`. This is the only function from the package that you’ll ever use!

The following example uses the two most important arguments in `R6Class()`:

1. `classname`: By convention, R6 classes have UpperCamelCase names. This also makes it possible to use R6 objects and S3 generics.

2. `public`: Supplies a list of __methods__ (i.e. functions) and __fields__ (i.e. anything else) that make up the public interface of the object. By convention, methods and fields use snake_case. Methods can access the methods and fields of the current object via `self$...`

```{r}
library(R6)

Accumulator <- R6Class("Accumulator", list(
  sum = 0,
  add = function(x = 1) {
    self$sum <- self$sum + x 
    invisible(self)
  })
)
```

>You should always assign the result of `R6Class()` into a variable with the same name as the class, because `R6Class()` returns an R6 object that defines the class:

```{r}
Accumulator
```

>You construct a new object from the class by calling the `new()` method. In R6, methods belong to objects, so you use `$` to access `new()`:

```{r}
x <- Accumulator$new()
```

Finally, you can call the methods and access the fields in `public` with the `$` operator.

```{r}
x$sum
x$add(25)
x$sum
x$add(1)$add(2)$add(3) ## method chaining
x$sum
```

When thinking about the translation between S3 and R6, recall that we talk about __fields__ and __methods__ as opposed to __variables__ and __functions__.

## Important methods





To do:

update with slides from 

https://blog.revolutionanalytics.com/2017/07/the-r6-class-system.html

functional vs encapsulated

public, private, initialize, inherits and super

here class methods are separate from objects, and objects are not mutable (that is, they can't be modified directly by methods; you have to assign modified values to the object directly). The R6 system, by contrast, is an encapsulated object oriented system akin to those in Java or C++, where objects contain methods in addition to data, and those methods can modify objects directly. 
