---
title: "<strong>Object-Oriented Programming</strong>"
author: "andrés castro araújo"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output: 
  html_document: 
    theme: paper
    toc: yes
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", fig.align = "center")

library(purrr)
```

```{css, echo=FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    color: #828282;
    border-left: 10px solid #EEE;
}

body {
    font-size: 14px;
}
```

>All of this is taken from Hadley Wickham's [__Advanced R__](https://adv-r.hadley.nz). CRC Press, 2019.

****

## Introduction

Object-oriented programming (OOP) in R can get complicated because there are multiple OOP to choose from. Here we focus on __S3__, __R6__, and __S4__.

>There is disagreement about the relative importance of the OOP systems. I think S3 is most important, followed by R6, then S4. Others believe that S4 is most important, followed by RC, and that S3 should be avoided. This means that different R communities use different systems.

S3 and S4 use __generic function OOP__ which is different from the __encapsulated OOP__ used in Python.

>S3 allows your functions to return rich results with user-friendly display and programmer-friendly internals. S3 is used throughout base R, so it’s important to master if you want to extend base R functions to work with new types of input.

>R6 provides a standardised way to escape R’s copy-on-modify semantics. This is particularly important if you want to model objects that exist independently of R. Today, a common need for R6 is to model data that comes from a web API, and where changes come from inside or outside of R.

>S4 is a rigorous system that forces you to think carefully about program design. It’s particularly well-suited for building large systems that evolve over time and will receive contributions from many programmers. This is why it is used by the Bioconductor project, so another reason to learn S4 is to equip you to contribute to that project.

People like to use OOP systems because of __polymorphism__.

>Polymorphism means that a developer can consider a function’s interface separately from its implementation, making it possible to use the same function form for different types of input.

In short, it's what allows functions like `predict()` to work seamlessly with different types of models. It's also what allows `summary()` to produce different outputs for different variable classes:

```{r}
summary(iris$Sepal.Length)  ## Numeric 
summary(iris$Species) ## Factor
```

In every OOP system, objects of different kinds have a different __class__. The implementation for a given class is called a __method__. 

>Roughly speaking, a class defines what an object _is_ and methods describe what that object can _do_. 

>The class defines the __fields__, the data possessed by every instance of that class. Classes are organised in a hierarchy so that if a method does not exist for one class, its parent’s method is used, and the child is said to __inherit__ behaviour. [...] The process of finding the correct method given a class is called __method dispatch__.

We usually divide OOP systems into two types:

1. __Encapsulated OOP__. Here, methods belong to classes and method calls typically look like this.

    $$
    \texttt{object.method(arg1, arg2)}
    $$

2. __Functional OOP__. Here, methods belong to __generic__ functions and method calls look like regular function calls:

    $$
    \texttt{generic(object, arg1, arg2)}
    $$
    
    
## Base Types

```{r}
library(sloop)
```

When people talk about R objects there's one potential source of confusion. John Chambers famously said that "Everything that exists in R is an object". But "while everything _is_ an object, not everything is object-oriented".

>This confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.

Here we distinguish between __base objects__ and __OO objects__. 

```{r, echo=FALSE, out.width="160px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/5d6b4926530f3da70f16b54dcdf1a55eb8fa3d71/703e0/diagrams/oo-venn.png"
)
```

We use `sloop::otype()` to figure out which is which.

```{r}
otype(1:10)
otype(iris)
```

>Technically, the difference between base and OO objects is that OO objects have a "class" attribute:

```{r}
attr(1:10, "class")
attr(iris, "class")
```

_Note. The class() function returns misleading results when applied to base objects_

```{r}
class(1:10)
```

___Base types___

>While only OO objects have a class attribute, every object has a _base type_.

```{r}
typeof(1:10)
typeof(iris)
```

>Base types do not form an OOP system because functions that behave differently for different base types are primarily written in C code that uses switch statements.

Here's an example of R base objects and their C equivalents:

__Vectors__

```{r, echo=FALSE}
tibble::tribble(
  ~R, ~C,
  "`NULL`",  "`NILSXP`", 
  "`logical`", "`LGLSXP`",
  "`integer`", "`INTSXP`",
  "`double`", "`REALSXP`",
  "`complex`", "`CPLXSXP`",
  "`character`", "`STRSXP`",
  "`list`", "`VECSXP`", 
  "`raw`", "`RAWSXP`"
) %>% 
  kableExtra::kable() %>% 
  kableExtra::kable_styling(bootstrap_options = "bordered")
```

```{r}
typeof(1)
typeof(1L)
typeof(1i)
```

__Functions__

```{r, echo=FALSE}
tibble::tribble(
  ~R, ~C,
  "`closure`", "`CLOSXP`",
  "`special`", "`SPECIALSXP`",
  "`builtin`", "`BUILTINSXP`"
) %>% 
  kableExtra::kable() %>% 
  kableExtra::kable_styling(bootstrap_options = "bordered")
```

```{r}
typeof(sum)
typeof(`<-`)
typeof(mean)
```

_In total, there are 25 different base types._

A final note. 

R users talk about a "numeric" type, which has become a permanent source of confusion for some of us. This is because "numeric" has at least three different meanings in R:

1. Sometimes "numeric" is synonymous with "double" (e.g. `as.numeric()` is identical to `as.double()`)

2. S3 and S4 systems use "numeric" for picking methods that work with either "double" or "integer" types.

```{r}
sloop::s3_class(1)
sloop::s3_class(1L)
```

3. Finally, we are sometimes interested in objects that behave like numbers. For example, factors are of type "integer" but don't behave like numbers.

```{r}
typeof(iris$Species)
is.numeric(iris$Species)
```

## S3

S3 is R's first and most used Object-Oriented system (it's used in the `base` and `stats` packages). It's minimalist. You should use it, unless you have a compelling reason to do otherwise.

> Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself. 

1. An S3 object is a base type with _at least_ a `class` attribute.

    For example, factors are integer types, have a `class` attribute "factor", and also a "levels" attribute.


    ```{r}
    fx <- factor(c("b", "a", "c"))
    typeof(fx)
    attributes(fx)
    ```

    If you `unclass()` a factor, it will lose it's special behavior.
    
    ```{r}
    unclass(fx)  ## equivalent to attr(fx, "class") <- NULL
    ```

- An S3 object behaves differently from its underlying base type whenever it’s passed to a __generic__ function.

    >A generic function defines an interface, which uses a different implementation depending on the class of an argument (almost always the first argument).

    ```{r}
    sloop::ftype(str)
    str(fx)
    str(unclass(fx))
    ```

    >The generic is a middleman: its job is to define the interface (i.e. the arguments) then find the right implementation for the job. The implementation for a specific class is called a __method__, and the generic finds that method by performing __method dispatch__.
    
All S3 methods are functions with a special naming scheme: `generic.class()`.  

```{r}
print.factor(fx)
```

But you should never call the method directly, instead rely on the generic to find the right function for you.

___Exercises.___

>Make a list of commonly used base R functions that contain `.` in their name but are not S3 methods.

Many functions in base R are point-separated, even though they are not `generic.method()` functions. They were written before S3. We can check if they're _methods_ using `sloop::ftype()`.

```{r}
sloop::ftype(print.factor)
sloop::ftype(t.test)
sloop::ftype(is.factor)
```

Here's a list of common point-separated functions that are _not_ methods:

```{r, eval=FALSE}
install.packages()
read.csv()
list.files()
download.file()
data.frame()
as.character()
Sys.Date()
all.equal()
do.call()
on.exit()
```

Unsurprisingly, many of these functions have "tidyverse" replacements that eliminate this ambiguity (e.g. `readr::read_csv()`).

### Classes

S3 has no formal definition of __class__. To make an object an instance of a class, you simply set the _class attribute_.

```{r}
# Create and assign class in one step
x <- structure(list(), class = "my_class") ## you can set any attribute here

# Create, then set class
x <- list()
class(x) <- "my_class"
```

>You can determine the class of an S3 object with `class(x)`, and see if an object is an instance of a class using `inherits(x, "classname")`.

```{r}
class(x)
inherits(x, "my_class")
```

>When using a class in a package, I recommend including the package name in the class name. That ensures you won’t accidentally clash with a class defined by another package.

>S3 has no checks for correctness which means you can change the class of existing objects:

```{r, error=TRUE}
# Create a linear model
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
print(mod)

# Turn it into a date (?!)
class(mod) <- "Date"

# Unsurprisingly this doesn't work very well
print(mod)

# Turning it back to normal
class(mod) <- "lm"
print(mod)
```

In practice, this immense flexibility shouldn't cause any problems.

>R doesn’t stop you from shooting yourself in the foot, but as long as you don’t aim the gun at your toes and pull the trigger, you won’t have a problem.

Wickham recommends having three functions when constructing new classes:

1. _A low-level **constructor**, `new_myclass()`, that efficiently creates new objects with the correct structure._ You should _always_ provide a constructor.

2. _A **validator**, `validate_myclass()`, that performs more computationally expensive checks to ensure that the object has correct values._

3. _A user-friendly **helper**, `myclass()`, that provides a convenient way for others to create objects of your class._

#### Constructors

The S3 system has no way to ensure that all objects of a given class have the same structure (i.e. "the same base type and the same attributes with the same types"). This is why we should use constructors to _enforce_ a consistent structure.

In general, these constructors should follow the same basic principles:

- They should have one argument for the base object, and one for each attribute.

- They should check the type of the base object and the types of each attribute.

_Example: The S3 `Date` class._

```{r}
new_Date <- function(x = double()) {
  stopifnot(is.double(x))
  structure(x, class = "Date")
}

class(new_Date(0))
```

_Example: The S3 `difftime` class._

```{r}
new_difftime <- function(x = double(), units = "secs") {
  stopifnot(is.double(x))
  units <- match.arg(units, c("secs", "mins", "hours", "days", "weeks"))

  structure(x,
    class = "difftime",
    units = units
  )
}

new_difftime(c(1, 4, 12), units = "week")
new_difftime(0, units = "mins")
```

>The constructor is a developer function: it will be called in many places, by an experienced user. That means it’s OK to trade a little safety in return for performance, and you should avoid potentially time-consuming checks in the constructor.

#### Validators

Constructors only check that types are correct. But some classes require complicated checks for validity.

_Example: The S3 `factor` class._

```{r, error=TRUE}
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  
  structure(x, class = "factor", levels = levels)
}

new_factor(1:5, "a")
```

>Rather than encumbering the constructor with complicated checks, it’s better to put them in a separate function. Doing so allows you to cheaply create new objects when you know that the values are correct, and easily re-use the checks in other places.

```{r, error=TRUE}
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }
  
  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }
  x
}
  
validate_factor(new_factor(0:1, "a"))
validate_factor(new_factor(1:5, "a"))
```

#### Helpers

Helpers strive to make the life of end users as easy as possible.

A helper should always:

1. _Have the same name as the class, e.g. `myclass()`._

2. _Finish by calling the constructor, and the validator, if it exists._

3. _Create carefully crafted error messages tailored towards an end-user._

4. _Have a thoughtfully crafted user interface with carefully chosen default values and useful conversions._

It's hard to give any general advice for this last bullet point, but Wickham does note three common patterns:

- _Sometimes all the helper needs to do is coerce its inputs to the desired type._

    ```{r, error=TRUE}
    new_difftime(1:10)
    ```
    
    >It’s not the job of the constructor to be flexible, so here we create a helper that just coerces the input to a double.

    ```{r, error=TRUE}
    difftime <- function(x = double(), units = "secs") {
      x <- as.double(x)
      new_difftime(x, units = units)
    }
    
    difftime(1:10)
    ```

- _Often, the most natural representation of a complex object is a string. For example, it’s very convenient to specify factors with a character vector._

```{r}
factor <- function(x = character(), levels = unique(x)) {
  # match returns a vector of the positions of (first) matches of its first
  # argument in its second.
  ind <- match(x, levels)
  validate_factor(new_factor(ind, levels))
}

x <- sample(letters[1:5], 10, replace = TRUE)
factor(x)
```

- _Some complex objects are most naturally specified by multiple simple components._

    >For example, it’s natural to construct a date-time by supplying the individual components (year, month, day etc). That leads to this `POSIXct()` helper that resembles the existing `ISODatetime()` function:
        
    ```{r}
    POSIXct <- function(year = integer(), 
                        month = integer(), 
                        day = integer(), 
                        hour = 0L, 
                        minute = 0L, 
                        sec = 0, 
                        tzone = "") {
      ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)
    }
    
    POSIXct(2020, 1, 1, tzone = "America/New_York")
    ```
    

___Exercises___

>Write a constructor for data.frame objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?

Data frames are built on top of named lists of vectors. Besides `class`, it has column `names` and `row.names` for attributes.

```{r}
typeof(mtcars)
attributes(mtcars)
```

A `data.frame` constructor:

```{r}
new_data.frame <- function(x = list(), row.names = NULL) {
  stopifnot(is.list(x))
  
  # Check all inputs are the same length
  rows <- unique(lengths(x))
  stopifnot(length(rows) <= 1)
  
  if (is.null(row.names)) {
     row.names <- if (length(rows) == 0) integer() else seq_along(1:rows)
   } else {
     stopifnot(is.character(row.names), 
               length(row.names) == unique(lengths(x)))
   }
  
  structure(x, class = "data.frame", row.names = row.names)
}

new_data.frame()
new_data.frame(list(c1 = 1:2, c2 = 2:3))
new_data.frame(list(c1 = 1:2, c2 = 2:3), row.names = c("a", "b"))
```

>Read the documentation for utils::as.roman(). How would you write a constructor for this class? Does it need a validator? What might a helper do?

`as.roman` turns integer numbers into roman numerals. It creates an object of class "roman".

```{r}
r <- as.roman(1:5)
attributes(r)
```

```{r}
new_roman <- function(x = integer()) {
  stopifnot(is.integer(x))
  structure(x, class = "roman")
}

r <- new_roman(1:5)
r
r^2
```

It needs a validator because "only numbers between 1 and 3899 have a unique representation as roman numbers, and hence others result in `as.roman(NA)`.

```{r, error=TRUE}
validate_roman <- function(x) {
  values <- unclass(x)

  if (any(values < 1 | values > 3899)) {
    stop(
      "Roman numbers must fall between 1 and 3899.",
      call. = FALSE
    )
  }
  x
}

validate_roman(4000L)
```

A helper function could be used to coerce real numbers into integers.

```{r}
roman <- function(x = integer()) {
  x <- as.integer(x)
  validate_roman(new_roman(x))
}

roman(rpois(5, 100))
```

### Generics and methods

S3 generics perform __method dispatch__, they find the specific implementation for a given class. This gets done by using the `UseMethod()` function, which is called by every generic (with the exception of _internal generics_).

>`UseMethod()` takes two arguments: the name of the generic function (required), and the argument to use for method dispatch (optional). If you omit the second argument, it will dispatch based on the first argument, which is almost always what is desired.

For example:

```{r}
print
mean
```

Thus, creating a new generic is a simple as this:

```{r}
my_new_generic <- function(x) {
  UseMethod("my_new_generic")
}
```

>When a function calling `UseMethod("fun")` is applied to an object with class attribute `c("first", "second")`, the system searches for a function called `fun.first` and, if it finds it, applies it to the object. If no such function is found a function called `fun.second` is tried. If no class name produces a suitable function, the function `fun.default` is used, if it exists, or an error results.

```{r, error=TRUE}
my_new_generic(1L)
```

In the above example, `1L` has an implicit class `c("integer", "numeric")`.

>Most vectors have class the result of `mode(x)`, except that integer vectors have class `c("integer", "numeric")` and real vectors have class `c("double", "numeric")`.

__How does method dispatch actually work?__

`UseMethod()` basically creates a vector of method names, and then looks for each potential method in turn.

```{r, eval=FALSE}
paste0("generic", ".", c(class(x), "default"))
```

This can create some very weird bugs if you are not careful about class names. For example, by creating a vector of class "test" and then calling the `t()` for matrix transposition, we end up calling the unrelated `t.test()` function.

```{r}
x <- structure(1:10, class = "test")
t(x)
```

This is the most compelling reason to why you should _never_ use `.`'s in function names.

We can see method dispatch in action with the `sloop::s3_dispatch()` function, which lists all possible methods when you call an S3 generic inside of it.

```{r}
x <- Sys.Date()
s3_dispatch(print(x))
```

Here,  "=>" indicates the method that is called, whereas "*" indicates a method that is not called, even though it is defined.

> The "default" class is a special __pseudo-class.__ This is not a real class, but is included to make it possible to define a standard fallback that is found whenever a class-specific method is not available.

>`sloop::s3_dispatch()` lets you find the specific method used for a single call. What if you want to find all methods defined for a generic or associated with a class? That's the job of `sloop::s3_methods_generic()` and `sloop::s3_methods_class()`:

```{r}
s3_methods_generic("mean")  # similar to methods()
s3_methods_class("table")
```

___Exercises.___

>Which base generic has the greatest number of defined methods?

```{r}
objs <- rlang::pkg_env("base") %>% as.list()
objs <- objs[map_lgl(objs, is.function)]
objs <- objs[map_lgl(names(objs), sloop::is_s3_generic)]
generic_function_names <- names(objs)

library(dplyr)

number_of_methods <- function(x) {
  s3_methods_generic(x) %>% 
    #filter(source == "base") %>% ## the number of methods can depend on the number
    nrow()                      ## of packages attached to the search path
}

tibble::tibble(fname = generic_function_names) %>% 
  mutate(n = map_int(fname, number_of_methods)) %>% 
  arrange(desc(n))
```

>Carefully read the documentation for `UseMethod()` and explain why the following code returns the results that it does.

```{r}
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}

g.default <- function(x) { c(x = x, y = y) } 

x <- 1
y <- 1

g.default(1)
g(1)
```

Calling `g.default(x = 1)` retrieves `y` from the global environment. But typing `g()` retrieves `y` from the environment enclosed by `g()`, similar to what would happen if `g()` was a function factory.

>What are the arguments to `[`? Why is this a hard question to answer?

The subsetting operator `[` is both "primitive" and "generic". Thus, we can't really take a look into its arguments. We can, however, take a look at some of the methods it implements.

```{r}
formals(`[.factor`)
formals(`[.Date`)
formals(`[.table`)
formals(`[.numeric_version`)
```

It's very likely that `[`'s arguments are just `x` and `...`. But we can't know for sure unless we inspect the underlying C code.

### Object styles

__Vector style__ classes like `Factor` and `Date` have one key property: `length(x)` represents the number of observations in the the vector. There are three object styles that don't have this property.

- __Record style__ objects use a list of equal-length vectors to represent individual components of the object. For example, `POSIXlt` is a list of 11 date-time components: year, month, day, hour, min, sec, etc.

    ```{r}
    x <- as.POSIXlt(c("2020-01-01", "2020-01-02"))
    str(unclass(x))
    ```

    Record style classes override `length()` and subsetting methods to conceal this implementation detail.
    
    ```{r}
    length(x)
    x[[1]]
    ```
    
- __Data frames__ are similar to record style objects in that both use lists of equal length vectors. But data frames are two dimensional, and the individual components are readily exposed to the user. The number of observations is given by `nrow(df)`, whereas `length(df)` gives us the number of columns.

- __Scalar objects__ typically use a list to represent one single thing. For example, an `lm` object is actually a list of length 12, even though it represents one model.

___Exercises.___

>Categorise the objects returned by `lm()`, `factor()`, `table()`, `as.Date()`, `as.POSIXct()`, `ecdf()`, `ordered()`, `I()` into the styles described above.

```{r, echo=FALSE}
tibble::tribble(
  ~`object from`, ~style,
  "`lm()`","scalar", 
  "`ecdf()`", "scalar",
  "`table()`", "vector",
  "`as.Date()`", "vector",
  "`as.POSIXct()`", "vector",
  "`as.POSIXlt()`", "record",
  "`I()`", "`other`"
) %>% 
  kableExtra::kable() %>% 
  kableExtra::kable_styling(bootstrap_options = "bordered")
```

### Inheritance

>S3 classes can share behaviour through a mechanism called __inheritance__.

This mechanism is powered by three things:

- The class can be a _character vector_.

    ```{r}
    class(ordered("x"))
    ```

    Here, `ordered` is a __subclass__ of `factor`; `factor` is __superclass__ of `ordered`.

- If a method is not found for the first class, R looks for a method for the second, and so on.

    ```{r}
    sloop::s3_dispatch(print(ordered("a")))
    ```

- A method can _delegate_ work by calling `NextMethod()`. 

    ```{r}
    sloop::s3_dispatch(ordered("a")[[1]])
    ```

    Note that `s3_dispatch()` reports delegation with "->".
    
___`NextMethod()`___

```{r}
new_secret <- function(x = double()) {
  stopifnot(is.double(x))
  structure(x, class = "secret")
}

print.secret <- function(x, ...) {
  print(strrep("x", nchar(x)))
  invisible(x)
}

x <- new_secret(c(15, 1, 456))
x
```

```{r}
sloop::s3_dispatch(x[1])
```


Unfortunately, the default `[` method can’t keep a secret (i.e. it doesn't preserve the `secret` class).


https://vctrs.r-lib.org/articles/s3-vector.html



## R6

R6 - very different to S3/S4, it's much more like OOP in python or javascript, or basically any other popular programming language of the last 20 years (apart from Julia). Powers reticulate. Useful in various places in Shiny. Avoided unless you really need it.

