---
title: "<strong>Functional Programming</strong>"
author: "andrés castro araújo"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output: 
  html_document: 
    theme: paper
    toc: yes
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", fig.align = "center")
```

```{css, echo=FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    color: #828282;
    border-left: 10px solid #EEE;
}

body {
    font-size: 14px;
}
```

>All of this is taken from Hadley Wickham's [__Advanced R__](https://adv-r.hadley.nz). CRC Press, 2019.

****

## Introduction

R lends itself to a _functional style_ of programming. 
 
>Functional languages have __first-class functions__, functions that behave _like any other data structure._ In R, this means that you can do many of the things with a function that you can do with a vector: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.

Many functional languages require that functions are __pure__ (i.e. that every input results in the same outputs). This is obviously not the case in R (e.g. `runif()`, `read.csv()`). So even though R isn't strictly speaking a functional language, it certainly resembles one.

>It’s hard to describe exactly what a functional _style_ is, but generally I think it means decomposing a big problem into smaller pieces, then solving each piece with a function or combination of functions. When using a functional style, you strive to decompose components of the problem into isolated functions that operate independently. Each function taken by itself is simple and straightforward to understand; complexity is handled by composing functions in various ways.

This notebook in particular is about __higher-order functions__. These functions can be categorized depending on their inputs and outputs, in accordance with this handy two-by-two table:

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/1dff819e743f280bbab1c55f8f063e60b6a0d2fb/2269e/diagrams/fp.png")
```

## Functionals

>A __functional__ is a function that takes a function as an input and returns a vector as output. Here’s a simple functional: it calls the function provided as input with 100 random uniform numbers.

```{r}
randomize <- function(f) f(runif(100))
randomize(mean)
randomize(sum)
```

>The chances are that you've already used a functional. You might have used for-loop replacements like base R's `lapply()`, `apply()`, and `tapply()`; or purrr's `map()`; or maybe you've used a mathematical functional like `integrate()` or `optim()`.

```{r}
integrate(dnorm, lower = 0, upper = Inf)
```

### Map

```{r, message=FALSE}
library(tidyverse)
```

The most important functional is ___`purrr::map()`___ (equivalent to `base::lapply()`): it takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list.

```{r}
map(1:3, function(x) x^2)  ## using anonymous or lambda function
```

The name "map" comes from mathematics, where "an operation that associates each element of a given set with one or more elements of a second set".

```{r, echo=FALSE, out.width="280px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/f0494d020aa517ae7b1011cea4c4a9f21702df8b/2577b/diagrams/functionals/map.png"
)
```

The inner workings of `map()` are pretty much what we can expect from a for loop:

```{r, eval=FALSE}
output <- vector("list", length(x))
for (i in seq_along(x)) {
  output[[i]] <- f(x[[i]])
}
```

There are many variants to `map()` that can be identified via conventional suffixes like `_dbl` to specify the type of _atomic vector_ we want to receive as output.

```{r}
map_chr(mtcars, is.numeric)  ## remember that data frames are lists of lists.
map_dbl(mtcars, max) %>% 
  map_dbl(round, digits = 1) ## using dot-dot-dot 
```

The `map()` family is different from `lapply()` (and other `base` variants) because it supports some shortcuts.

For example, the "twiddle" syntax (~):

```{r}
identical(
  map_dbl(mtcars, ~ length(unique(..1))),          ## twiddle syntax
  map_dbl(mtcars, function(x) length(unique(x)))   ## alternative
  )

map(1:3, ~ rnorm(10)) %>% str()                         ## twiddle syntax
map(1:3, function(x) rnorm(10)) %>% str()               ## alternative
replicate(n = 3, rnorm(10), simplify = FALSE) %>% str() ## other alternative
```

_Varying a different argument_

>So far the first argument to `map()` has always become the first argument to the function. But what happens if the first argument should be constant, and you want to vary a different argument? How do you get the result in this picture?

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/6d0b927ba5266f886cc721ae090afcc5e872a748/f8636/diagrams/functionals/map-arg-flipped.png"
)
```

```{r}
draws <- rcauchy(1000)
trims <- c(0, 0.1, 0.2, 0.5)

map_dbl(trims, ~ mean(draws, trim = ..1))
map_dbl(trims, function(input) mean(x = draws, trim = input))
map_dbl(trims, mean, x = draws) ## using R's flexible argument matching
```

__Piping multiple `purrr` functions__

```{r}
base::split(mtcars, mtcars$cyl) %>% ## split data frame into three, by cyl
  map(function(df) lm(mpg ~ wt, data = df)) %>% ## fit linear model three times
  map(coefficients) %>% ## access coefficients
  map_dbl(pluck, "wt")  ## extract slope

## Loop alternative
slopes <- vector("double", 3)
for (i in seq_along(slopes)) {
  model <- lm(mpg ~ wt, data = base::split(mtcars, mtcars$cyl)[[i]])
  slopes[[i]] <- coef(model)[["wt"]]
}
slopes
```

___Exercises.___

>`map(1:3, ~ runif(2))` is a useful pattern for generating random numbers, but `map(1:3, runif(2))` is not. Why not? Can you explain why it returns the result that it does?

`map()` uses `as_mapper()` to turn it's second argument into a function that then gets applied to each element in the first argument. 

In the first case, the twiddle syntax succesfully turns `~ runif(2)` into an anonymous function that then gets applied one time for every iteration.

In the second case, `as_mapper()` fails to turn `runif(2)` into a function. If the second argument is a _character vector_, _numeric vector_, or _list_, then `as_mapper()` turns this into an extractor function that uses `purr::pluck()` to extract elements.

```{r}
as_mapper(~runif(2))
as_mapper(runif(2))
```

This is how it works:

```{r}
identical(map(1:3, 1), map(1:3, pluck, 1))
```

>Use the appropriate `map()` function to:

```{r}
# 1. Compute the standard deviation of every column in a numeric data frame.
map_dbl(mtcars, sd)

# 2. Compute the standard deviation of every numeric column in a mixed data frame.
index <- map_lgl(iris, is.numeric)
map_dbl(iris[index], sd)

# Compute the number of levels for every factor in a data frame.
map(iris[!index], attr, which = "levels")
```

>The following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.

```{r, fig.height=3, fig.width=6}
trials <- map(1:1000, ~ t.test(rpois(10, 10), rpois(7, 10)))

tibble(p = map_dbl(trials, "p.value")) %>% 
  ggplot(aes(p)) + geom_histogram(binwidth = 0.05, color = "black")
```

>Use map() to fit linear models to the mtcars dataset using the formulas stored in this list:

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

formulas %>% 
  map(~ lm(..1, data = mtcars)) %>% 
  map(coefficients)
```

>Fit the model `mpg ~ disp` to each of the bootstrap replicates of mtcars in the list below, then extract the $R^2$ of the model fit.

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))

bootstraps %>% 
  map(function(df) lm(mpg ~ disp, data = df)) %>% 
  map(summary) %>% 
  map_dbl("r.squared") ## extractor 
```

### Varieties of Map

- Output same type as input with `modify()`

- Iterate over two inputs with `map2()`

- Iterate with an index using `imap()`

- Return nothing with `walk()`

- Iterate over any number of inputs with `pmap()`


INSERT TABLE

__Same type of output as input: `modify()`__

```{r}
df <- data.frame(
  x = 1:3,
  y = 6:4
)

map(df, scale) %>% str()  ## returns a list
modify(df, scale)         ## returns a data.frame
```

__Two inputs: `map2()` and friends__

```{r, error=TRUE}
## Example: finding a weighted mean
x <- map(1:5, ~ rnorm(20))
wt <- map(1:5, ~ runif(20))

weighted.mean(x[[1]], wt[[1]]) ## first element of each list

## Passing wt as an additional argument doesn’t work because arguments
## after .f are not transformed:
map(x, weighted.mean, w = wt) 
```

For this we use the `map2()` variety, which is vectorised over two arguments. This means both `..1` and `..2` are varied in each call to `weighted.mean`

```{r}
x[[3]][[3]] <- NA
map2_dbl(x, wt, weighted.mean)
map2_dbl(x, wt, weighted.mean, na.rm = TRUE)
```

```{r, echo=FALSE, out.width="350px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/7a545699ff7069a98329fcfbe6e42b734507eb16/211a5/diagrams/functionals/map2-arg.png"
)
```

__No outputs: `walk()` and friends__

>Some functions are called primarily for their side-effects (e.g. `cat()`, `write.csv()`, or `ggsave()`) and it doesn’t make sense to capture their results.

```{r}
eat_fruit <- function(x) {
  cat("Eat some more ", x, "!\n", sep = "")
}

sample(fruit, size = 5) %>% 
  map(eat_fruit)
```

To prevent `NULL` from showing up, we use `walk()`, which returns the input values through `invisible()`.

```{r}
sample(fruit, size = 5) %>% 
  walk(eat_fruit)

walk(1:5, ~ rnorm(10))
```

A very common use case for this pattern is saving some object to disk.

```{r}
temp <- tempfile()
dir.create(temp)

species <- split(iris, iris$Species)  ## list of three
paths <- file.path(temp, paste0("species-", names(species), ".rds"))
walk2(species, paths, write_rds)

list.files(temp)
read_rds(paste0(temp, "/species-setosa.rds")) %>% head()
```

__Iterating over values and indices__

>There are three basic ways to loop over a vector with a for loop:

- Loop over the elements: `for (x in xs)`

- Loop over the numeric indices: `for (i in seq_along(xs))`

- Loop over the names: `for (nm in names(xs))`

>The first form is analogous to the map() family. The second and third forms are equivalent to the imap() family which allows you to iterate over the values and the indices of a vector in parallel.

>`imap()` is like `map2()` in the sense that your `.f` gets called with two arguments, but here both are derived from the vector. `imap(x, f)` is equivalent to `map2(x, names(x), f)` if `x` has names, and `map2(x, seq_along(x), f)` if it does not.

```{r}
## example: constructing labels
imap_chr(iris, ~ paste0("The first value in ", ..2, " is ", ..1[[1]]))
```

__Any number of inputs: `pmap()` and friends__

`pmap()` functions avoid the need to have `map3()`, `map4()`, `map5()`, etc.

>There’s a simple equivalence between `map2()` and `pmap()`: `map2(x, y, f)` is the same as `pmap(list(x, y), f)`.

For example:

```{r, echo=FALSE, out.width="300px"}
identical(
  pmap_dbl(list(x, wt), weighted.mean),
  map2_dbl(x, wt, weighted.mean)
  )
```

```{r}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/2eb2eefe34ad6d114da2a22df42deac8511b4788/5a538/diagrams/functionals/pmap-arg.png"
)
```

>A big difference between `pmap()` and the other map functions is that _`pmap()` gives you much finer control over argument matching because you can name the components of the list._

```{r}
draws <- rcauchy(1000)
trims <- c(0, 0.1, 0.2, 0.5)

identical(
  map_dbl(trims, function(input) mean(x = draws, trim = input)),
  pmap_dbl(list(trim = trims), mean, x = draws)
  )
```

Note that name matching makes `pmap()` very easy to work with data frames. 

For example:

```{r}
params <- data.frame(       ## Here, the column names
  n = c(1, 3, 5),           ## are critical!
  mean = c(0, 10, 1000),
  sd = c(1, 10, 100)
)

params

pmap(params, rnorm)
```

___Exercises___

>Rewrite the following code to use `iwalk()` instead of `walk2()`. What are the advantages and disadvantages?

```{r}
temp <- tempfile()
dir.create(temp)

cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))

## ORIGINAL
walk2(cyls, paths, write.csv)
list.files(temp)

## RE-WRITE
names(cyls) <- paths      ## Disadvantage: names are overwritten
iwalk(cyls, ~ write.csv)  ## Advantage: code is slightly shorter
list.files(temp)
```

### Reduce and Accumulate

>After the map family, the next most important family of functions is the reduce family. This family is much smaller, with only two main variants, and is used less commonly, but it's a powerful idea, gives us the opportunity to discuss some useful algebra, and powers the map-reduce framework frequently used for processing very large datasets.

>[`reduce()`](https://purrr.tidyverse.org/reference/reduce.html) takes a vector of length `n` and produces a vector of length `1` by calling a function with a pair of values at a time: `reduce(1:4, f)` is equivalent to `f(f(f(1, 2), 3), 4)`.

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/9c239e1227c69b7a2c9c2df234c21f3e1c74dd57/eec0e/diagrams/functionals/reduce.png"
)
```

For example, suppose we have 4 lists that contain fruit, and we want to figure out how what are the fruits common to _all_ of them. To do this, we have to call intersect five times (each time using the results of the previous call).

```{r}
fruit_lists <- map(1:4, ~sample(fruit, 35))

## This...
fruit_lists[[1]] %>% 
  intersect(fruit_lists[[2]]) %>% 
  intersect(fruit_lists[[3]]) %>% 
  intersect(fruit_lists[[4]]) 

## ...is equivalent to this
reduce(fruit_lists, intersect)
```

`accumulate()` is a variant of `reduce()` that returns all the intermediate results as well.

```{r}
accumulate(fruit_lists, intersect)
```

__Note.__ These two functions behave a lot like `sum()` and `cumsum()`.

```{r}
x <- c(4, 3, 10, 12)
reduce(x, `+`) ## sum()
accumulate(x, `+`) ## cumsum()
```

Finally, the `.init` argument allows you to supply an initial element to these functions.

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/b5835b80325b22f9460992f7bc9de5e0cf56de2c/27994/diagrams/functionals/reduce-init.png"
)
```

>So if we call `reduce(1, `+`, init)` the result will be `1 + init`.

```{r}
reduce(1:2, `+`, .init = 1)
```

This argument can become important if you are not sure what you're input might look like, and you want to avoid an error. In mathematics, we refer to the `.init` argument as the [identity element](https://en.wikipedia.org/wiki/Identity_element): "a special type of element of a set with respect to a binary operation on that set, which leaves any element of the set unchanged when combined with it."

```{r}
sum(integer())
prod(integer())
```

>If you’re using `reduce()` in a function, you should always supply `.init`. Think carefully about what your function should return when you pass a vector of length `0` or `1`, and make sure to test your implementation.

___Map-reduce___

>You might have heard of map-reduce, the idea that powers technology like Hadoop. Now you can see how simple and powerful the underlying idea is: map-reduce is a map combined with a reduce. The difference for large data is that the data is spread over multiple computers. Each computer performs the map on the data that it has, then it sends the result to back to a coordinator which reduces the individual results back to a single result.
>
>As a simple example, imagine computing the mean of a very large vector, so large that it has to be split over multiple computers. You could ask each computer to calculate the sum and the length, and then return those to the coordinator which computes the overall mean by dividing the total sum by the total length.


### Predicates

>A __predicate__ is a function that returns a single `TRUE` or `FALSE`, like `is.character()`, `is.null()`, or `all()`, and we say a predicate _matches_ a vector if it returns `TRUE.`

The `purrr` package has three pairs of useful functions that apply a predicate to each element in a vector.

1. _`some(.x, .p)` returns TRUE if any element matches; `every(.x, .p)` returns TRUE if all elements match._

    _These are equivalent to `any(map_lgl(.x, .p))` and `all(map_lgl(.x, .p))`, except that they terminate early: `some()` returns `TRUE` when it sees the first `TRUE`, and `every()` returns `FALSE` when it sees the first `FALSE.`_

2. _`detect(.x, .p)` returns the_ value _of the first match; `detect_index(.x, .p)` returns the_ location _of the first match._

3. _`keep(.x, .p)`_ keeps _all matching elements; `discard(.x, .p)`_ drops _all matching elements._

```{r}
df <- data.frame(
  x = 1:3,
  y = c("a", "b", "c")  ## stringsAsFactors = TRUE by default
  )

every(df, is.factor)
some(df, is.factor)

detect(df, is.integer)
detect_index(df, is.factor)

keep(df, is.factor) %>% str()
discard(df, is.factor) %>% str()
```

Note the following:

>`map()` and `modify()` come in variants that also take predicate functions, transforming only the elements of `.x` where `.p` is `TRUE`.

```{r}
map_if(df, is.numeric, mean) %>% str()
modify_if(df, is.numeric, max) %>% str()

## this will drop the factor, and avoid recycling
keep(df, is.numeric) %>% map(mean) %>% str()
```

___Exercises___



### Extra
