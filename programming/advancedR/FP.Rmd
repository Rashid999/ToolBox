---
title: "<strong>Functional Programming</strong>"
author: "andrés castro araújo"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output: 
  html_document: 
    theme: paper
    toc: yes
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", fig.align = "center")
```

```{css, echo=FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    color: #828282;
    border-left: 10px solid #EEE;
}

body {
    font-size: 14px;
}
```

>All of this is taken from Hadley Wickham's [__Advanced R__](https://adv-r.hadley.nz). CRC Press, 2019.

****

## Introduction

R lends itself to a _functional style_ of programming. 
 
>Functional languages have __first-class functions__, functions that behave _like any other data structure._ In R, this means that you can do many of the things with a function that you can do with a vector: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.

Many functional languages require that functions are __pure__ (i.e. that every input results in the same outputs). This is obviously not the case in R (e.g. `runif()`, `read.csv()`). So even though R isn't strictly speaking a functional language, it certainly resembles one.

>It’s hard to describe exactly what a functional _style_ is, but generally I think it means decomposing a big problem into smaller pieces, then solving each piece with a function or combination of functions. When using a functional style, you strive to decompose components of the problem into isolated functions that operate independently. Each function taken by itself is simple and straightforward to understand; complexity is handled by composing functions in various ways.

This notebook in particular is about __higher-order functions__. These functions can be categorized depending on their inputs and outputs, in accordance with this handy two-by-two table:

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/1dff819e743f280bbab1c55f8f063e60b6a0d2fb/2269e/diagrams/fp.png")
```

## Functionals

>A __functional__ is a function that takes a function as an input and returns a vector as output. Here’s a simple functional: it calls the function provided as input with 100 random uniform numbers.

```{r}
randomize <- function(f) f(runif(100))
randomize(mean)
randomize(sum)
```

>The chances are that you've already used a functional. You might have used for-loop replacements like base R's `lapply()`, `apply()`, and `tapply()`; or purrr's `map()`; or maybe you've used a mathematical functional like `integrate()` or `optim()`.

```{r}
integrate(dnorm, lower = 0, upper = Inf)
```

### Map

```{r}
library(purrr)
```

The most important functional is ___`purrr::map()`___ (equivalent to `base::lapply()`): it takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list.

```{r}
map(1:3, function(x) x^2)  ## using anonymous or lambda function
```

The name "map" comes from mathematics, where "an operation that associates each element of a given set with one or more elements of a second set".

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/f0494d020aa517ae7b1011cea4c4a9f21702df8b/2577b/diagrams/functionals/map.png"
)
```

The inner workings of `map()` are pretty much what we can expect from a for loop:

```{r, eval=FALSE}
output <- vector("list", length(x))
for (i in seq_along(x)) {
  output[[i]] <- f(x[[i]])
}
```

There are many variants to `map()` that can be identified via conventional suffixes like `_dbl` to specify the type of _atomic vector_ we want to receive as output.

```{r}
map_chr(mtcars, is.numeric)  ## remember that data frames are lists of lists.
map_dbl(mtcars, max) %>% 
  map_dbl(round, digits = 1) ## using dot-dot-dot 
```

The `map()` family is different from `lapply()` (and other `base` variants) because it supports some shortcuts.

For example, the "twiddle" syntax (~):

```{r}
identical(
  map_dbl(mtcars, ~ length(unique(..1))),          ## twiddle syntax
  map_dbl(mtcars, function(x) length(unique(x)))   ## alternative
  )

map(1:3, ~ rnorm(10)) %>% str()                         ## twiddle syntax
map(1:3, function(x) rnorm(10)) %>% str()               ## alternative
replicate(n = 3, rnorm(10), simplify = FALSE) %>% str() ## other alternative
```

_Varying a different argument_

>So far the first argument to `map()` has always become the first argument to the function. But what happens if the first argument should be constant, and you want to vary a different argument? How do you get the result in this picture?

```{r, echo=FALSE, out.width="300px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/6d0b927ba5266f886cc721ae090afcc5e872a748/f8636/diagrams/functionals/map-arg-flipped.png"
)
```

```{r}
draws <- rcauchy(1000)
trims <- c(0, 0.1, 0.2, 0.5)

map_dbl(trims, ~ mean(draws, trim = ..1))
map_dbl(trims, function(input) mean(x = draws, trim = input))
map_dbl(trims, mean, x = draws) ## using R's flexible argument matching
```

__Piping multiple `purrr` functions__

```{r}
base::split(mtcars, mtcars$cyl) %>% ## split data frame into three, by cyl
  map(function(df) lm(mpg ~ wt, data = df)) %>% ## fit linear model three times
  map(coefficients) %>% ## access coefficients
  map_dbl(pluck, "wt")  ## extract slope

## Loop alternative
slopes <- vector("double", 3)
for (i in seq_along(slopes)) {
  model <- lm(mpg ~ wt, data = base::split(mtcars, mtcars$cyl)[[i]])
  slopes[[i]] <- coef(model)[["wt"]]
}
slopes
```

___Exercises.___

>`map(1:3, ~ runif(2))` is a useful pattern for generating random numbers, but `map(1:3, runif(2))` is not. Why not? Can you explain why it returns the result that it does?

`map()` uses `as_mapper()` to turn it's second argument into a function that then gets applied to each element in the first argument. 

In the first case, the twiddle syntax succesfully turns `~ runif(2)` into an anonymous function that then gets applied one time for every iteration.

In the second case, `as_mapper()` fails to turn `runif(2)` into a function. If the second argument is a _character vector_, _numeric vector_, or _list_, then `as_mapper()` turns this into an extractor function that uses `purr::pluck()` to extract elements.

```{r}
as_mapper(~runif(2))
as_mapper(runif(2))
```

This is how it works:

```{r}
identical(map(1:3, 1), map(1:3, pluck, 1))
```

>Use the appropriate `map()` function to:

```{r}
# 1. Compute the standard deviation of every column in a numeric data frame.
map_dbl(mtcars, sd)

# 2. Compute the standard deviation of every numeric column in a mixed data frame.
index <- map_lgl(iris, is.numeric)
map_dbl(iris[index], sd)

# Compute the number of levels for every factor in a data frame.
map(iris[!index], attr, which = "levels")
```

>The following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.

```{r, fig.height=3, fig.width=6}
trials <- map(1:1000, ~ t.test(rpois(10, 10), rpois(7, 10)))

tibble(p = map_dbl(trials, "p.value")) %>% 
  ggplot(aes(p)) + geom_histogram(binwidth = 0.05, color = "black")
```

>Use map() to fit linear models to the mtcars dataset using the formulas stored in this list:

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

formulas %>% 
  map(~ lm(..1, data = mtcars)) %>% 
  map(coefficients)
```

>Fit the model `mpg ~ disp` to each of the bootstrap replicates of mtcars in the list below, then extract the $R^2$ of the model fit.

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))

bootstraps %>% 
  map(function(df) lm(mpg ~ disp, data = df)) %>% 
  map(summary) %>% 
  map_dbl("r.squared") ## extractor 
```

### Varieties of Map

### Reduce


### Predicates



### Extra
